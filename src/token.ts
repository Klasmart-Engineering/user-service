import { AuthenticationError } from 'apollo-server-express'
import express, { Request } from 'express'
import { decode, Secret, verify, VerifyOptions } from 'jsonwebtoken'
import getAuthenticatedUser from './services/azureAdB2C'
import { customErrors } from './types/errors/customError'
import clean from './utils/clean'
import { stringInject } from './utils/stringUtils'
import { getEnvVar } from './config/config'

const IS_AZURE_B2C_ENABLED = getEnvVar('AZURE_B2C_ENABLED', 'false') === 'true'
const issuers = new Map<
    string,
    {
        options: VerifyOptions
        secretOrPublicKey: Secret
    }
>([
    [
        'kidsloop',
        {
            options: {
                issuer: 'kidsloop',
                algorithms: ['RS512'],
            },
            secretOrPublicKey: `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxdHMYTqFobj3oGD/JDYb
DN07icTH/Dj7jBtJSG2clM6hQ1HRLApQUNoqcrcJzA0A7aNqELIJuxMovYAoRtAT
E1pYMWpVyG41inQiJjKFyAkuHsVzL+t2C778BFxlXTC/VWoR6CowWSWJaYlT5fA/
krUew7/+sGW6rjV2lQqxBN3sQsfaDOdN5IGkizsfMpdrETbc5tKksNs6nL6SFRDe
LoS4AH5KI4T0/HC53iLDjgBoka7tJuu3YsOBzxDX22FbYfTFV7MmPyq++8ANbzTL
sgaD2lwWhfWO51cWJnFIPc7gHBq9kMqMK3T2dw0jCHpA4vYEMjsErNSWKjaxF8O/
FwIDAQAB
-----END PUBLIC KEY-----`,
        },
    ],
    [
        'KidsLoopChinaUser-live',
        {
            options: {
                issuer: 'KidsLoopChinaUser-live',
                algorithms: ['RS512'],
            },
            secretOrPublicKey: [
                '-----BEGIN PUBLIC KEY-----',
                'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDAGN9KAcc61KBz8EQAH54bFwGK',
                '6PEQNVXXlsObwFd3Zos83bRm+3grzP0pKWniZ6TL/y7ZgFh4OlUMh9qJjIt6Lpz9',
                'l4uDxkgDDrKHn8IrflBxjJKq0OyXqwIYChnFoi/HGjcRtJhi8oTFToSvKMqIeUuL',
                'mWmLA8nXdDnMl7zwoQIDAQAB',
                '-----END PUBLIC KEY-----',
            ].join('\n'),
        },
    ],
])

if (process.env.NODE_ENV === 'development') {
    issuers.set('calmid-debug', {
        options: {
            issuer: 'calmid-debug',
            algorithms: ['HS512', 'HS384', 'HS256'],
        },
        secretOrPublicKey: 'iXtZx1D5AqEB0B9pfn+hRQ==',
    })
}

export interface TokenPayload {
    // id is not set until client has selected
    // a particular user profile
    id?: string
    email?: string
    phone?: string
    iss: string

    user_name?: string
}

async function checkTokenAMS(req: Request): Promise<TokenPayload> {
    const token = req.headers.authorization || req.cookies.access
    if (!token) {
        throw new AuthenticationError('No authentication token')
    }
    const payload = decode(token)
    if (!payload || typeof payload === 'string') {
        throw new AuthenticationError('Malformed authentication token')
    }
    const issuer = payload['iss']
    if (!issuer || typeof issuer !== 'string') {
        throw new AuthenticationError('Malformed authentication token issuer')
    }
    const issuerOptions = issuers.get(issuer)
    if (!issuerOptions) {
        throw new AuthenticationError('Unknown authentication token issuer')
    }
    const { options, secretOrPublicKey } = issuerOptions
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const verifiedToken = await new Promise<any>((resolve, reject) => {
        verify(token, secretOrPublicKey, options, (err, decoded) => {
            if (err) {
                reject(err)
            }
            if (decoded) {
                resolve(decoded)
            }
            reject(new AuthenticationError('Unexpected authorization error'))
        })
    })
    return verifiedToken
}

export async function checkToken(req: Request): Promise<TokenPayload> {
    let tokenPayload: TokenPayload
    if (IS_AZURE_B2C_ENABLED) {
        const azureTokenPayload = await getAuthenticatedUser(req)
        const { emails, ...rest } = azureTokenPayload
        tokenPayload = {
            ...rest,
            id: azureTokenPayload.sub,
            iss: azureTokenPayload.iss,
            email: emails && emails?.length > 0 ? emails[0] : '',
        }
    } else {
        tokenPayload = await checkTokenAMS(req)
    }

    // the auth service that create our tokens does not normalize emails
    // as strictly as we do
    // https://calmisland.atlassian.net/browse/AD-1133?focusedCommentId=56306
    // therefor we must normalize them ourselves to ensure they match up
    // with what is saved to our db
    // cast is ok because clean.email only return null if input is null
    tokenPayload.email = clean.email(tokenPayload.email) as string | undefined

    return tokenPayload
}

export function isAPIKey(auth: string) {
    return auth.startsWith('Bearer ')
}

export function checkAPIKey(auth: string) {
    if (!isAPIKey(auth)) {
        return false
    }
    const clientApiKey = auth.substr(7)
    const serverApiKey = getEnvVar('USER_SERVICE_API_KEY')
    if (clientApiKey === serverApiKey) {
        return true
    }
    throw Error('Invalid API Key')
}

export type resLocal = { token?: TokenPayload | undefined; hasApiKey?: boolean }
export async function validateToken(
    req: express.Request,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    res: express.Response<any, resLocal>,
    next: express.NextFunction
) {
    const auth = req.headers.authorization

    if (auth !== undefined && isAPIKey(auth)) {
        try {
            res.locals.hasApiKey = checkAPIKey(auth)
        } catch (e) {
            const { code, message } = customErrors.invalid_api_key
            return res.status(401).send({
                code,
                message: stringInject(message, { reason: e.message })!,
            })
        }
    } else {
        try {
            res.locals.token = await checkToken(req)
        } catch (e) {
            const { code, message } = customErrors.invalid_token

            return res.status(401).send({
                code,
                message: stringInject(message, { reason: e.message })!,
            })
        }
    }
    next()
}
